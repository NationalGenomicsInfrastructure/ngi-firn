# Data handling

## Data storage

This application uses **CouchDB** as the document database, connected via the **IBM Cloudant** library. CouchDB is a NoSQL document database that stores data in JSON format, making it flexible for storing complex data structures.

### Document database with CouchDB

#### Primer

CouchDB is a document-oriented NoSQL database that stores data in JSON format. Unlike relational databases, CouchDB doesn't require a predefined schema, allowing for flexible data structures. Each document has a unique ID and can contain any valid JSON data. CouchDB provides ACID compliance and supports replication for high availability.

The application uses the IBM Cloudant library to interact with CouchDB, which provides a comprehensive API for document operations, queries, and indexing.

#### Document Structure

Documents in this application follow a consistent structure:

- `_id`: Unique document identifier (auto-generated by CouchDB)
- `_rev`: Document revision (used for optimistic concurrency control)
- `type`: Document type identifier (e.g., 'todo')
- Additional fields specific to each document type

For example, a todo document looks like:
```json
{
  "_id": "123",
  "_rev": "1-abc123",
  "type": "todo",
  "userId": "github_123456",
  "title": "Complete project documentation",
  "completed": 0,
  "createdAt": "2024-01-15T10:30:00.000Z"
}
```

#### Database Operations

The database operations are handled through the `CouchDBConnector` class in `server/database/couchdb.ts`:

- **Create**: `createDocument()` - Creates a new document
- **Read**: `getDocument()` - Retrieves a document by ID
- **Update**: `updateDocument()` - Updates an existing document (requires revision)
- **Delete**: `deleteDocument()` - Deletes a document (requires revision)
- **Query**: `queryDocuments()` - Performs Mango queries for complex searches

#### Indexing

CouchDB uses indexes to improve query performance. The application creates the following indexes:

- `type_userid_idx`: For querying documents by type and user ID
- `type_userid_completed_idx`: For querying todos by type, user ID, and completion status
- `type_createdat_idx`: For querying documents by type and creation date

#### Configuration

The database connection is configured through environment variables:

- `COUCHDB_URL`: CouchDB server URL (default: http://localhost:5984)
- `COUCHDB_USERNAME`: Username for authentication
- `COUCHDB_PASSWORD`: Password for authentication
- `COUCHDB_DATABASE`: Database name (default: 'firn')

## Data fetching

For data transmission between the `server` and the client `app`, traditional [REST](./api.md) and [tRPC](./trpc.md) are available. The latter is preferred.

### Optimistic updates

When building user interfaces, fast reactivity is an easily overlooked, but relevant factor for good user experience. As a rule of thumb, [actions that are completed in 100ms](https://medium.com/shakuro/milliseconds-matter-how-time-builds-ux-6cac50fb472e) or less are perceived instantaneous by human users. For that reason, you will want to give a user the impression that something has happened, even if the server takes longer to handle the request. 

In an _optimistic update_, the user interface behaves as though a change was successfully completed before receiving confirmation from the server that it actually was - it is being optimistic that it will eventually get the confirmation rather than an error. This allows for a more responsive user experience.

When you optimistically update the state in your client before performing a mutation, there is, however, a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to rollback the client's state update.

For a single component, this is relatively straightforward using variables and updating the UI directly. However, if you have multiple places on the screen that would require to know about the update, manipulating the store directly will take care of these rollbacks for you automatically. That is exactly cache invalidation with [Pinia Colada](https://pinia-colada.esm.dev) is simplifying.

