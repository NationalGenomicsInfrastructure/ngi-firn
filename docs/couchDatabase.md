# Document database with CouchDB

## Primer

CouchDB is a document-oriented NoSQL database that stores data in JSON format. Unlike relational databases, CouchDB does not require a predefined schema â€” each document can contain any valid JSON structure, providing flexibility for a variety of use cases.

In practice, however, data also needs to be modelled for document-oriented databases, because the application expects a certain shape of the object to process it correctly. Please see the [Data Modeling and Schema Fundamentals section](./#Data-Modeling-and-Schema-Fundamentals) for a coarse summary of the main considerations.

In this application, we enforce consistency by defining each document type as a TypeScript interface. This approach ensures that all documents follow a standardized structure, making the data model predictable and allowing the TypeScript typechecker to validate all properties and types at compile time.

## Documents

### Document Structure

Documents in this application follow a consistent structure with required properties:

- `_id`: Unique document identifier (auto-generated by CouchDB)
- `_rev`: Document revision (used for optimistic concurrency control)
- `schema`: The version of a document's schema. If properties change, it **must* be incremented by 1.
- `type`: Document type identifier (e.g., `todo` or `user`)
- Additional properties are specific to each document type

For example, a todo document may look like:

```json
{
  "_id": "123",
  "_rev": "1-abc123",
  "_schema": 1,
  "type": "todo",
  "userId": "github_123456",
  "title": "Complete project documentation",
  "completed": 0,
  "createdAt": "2024-01-15T10:30:00.000Z"
}
```

### Document Schemas

We declare the different document schemas (object shapes) for our application's entities as Typescript interfaces in the `types` folder. The base document that provides the `_id` and `_rev` properties is extended by the specific properties and their types.

```ts
import type { BaseDocument } from '../server/database/couchdb'

// Define the Todo type for CouchDB documents
export interface Todo extends BaseDocument {
  type: 'todo'
  userId: string // GitHub or Google ID
  title: string
  completed: number // 0 or 1
  createdAt: string // ISO date string
}
```

### Data Modeling and Schema Fundamentals

Despite their flexibility, data modeling in document databases involves careful consideration of how data is structured and related. While materials specific to CouchDB are scarce, teaching material that applies to e.g. [MongoDB](https://www.mongodb.com/docs/manual/data-modeling/) mostly applies to Firn's CouchDB as well.

Please find here a brief summary of [advisable patterns](https://www.mongodb.com/docs/manual/data-modeling/design-patterns/) and [anti-patterns](https://www.mongodb.com/docs/manual/data-modeling/design-antipatterns/).

#### Embedding vs. linking

One key decision is whether to **embed** related data within a document (embedding) or to **link** documents using references (linking), the equivalent of a foreign key in a relational database management system.

Embedding is suitable for data that is frequently accessed together and does not change independently. For most `1:1` or `1:n` relationships, embedding is the right choice, unless the embedded content is very large. In that case, retrieving the parent document would be slow. 

In Firn, we have for example opted to embed the last few actions performed with a plate, but link the full history of a plate in a separate document, so it will only be retrieved when actually requested.

Linking is preferable for data that is shared across multiple documents (`n:n` - many to many relationships), updated separately or so large, that it would bog down the documents.

[Detailed considerations](https://www.mongodb.com/docs/manual/data-modeling/concepts/embedding-vs-references/)

### Optimize for access

It is important to design documents and indexes to match the application's most common access patterns, minimizing the need for expensive joins or multiple queries. This often involves denormalizing data or creating compound indexes on frequently queried fields.

### Always increment versions when changing the data model

As application requirements evolve, **versioned schemas** allow for safe and incremental changes to document structures. By including a `schema` property in each document, our application can handle migrations and maintain compatibility with older data, ensuring robust and maintainable data models over time.

We can ensure to handle documents with an older schema appropriately with a different application logic, bulk update them or update them when anyway accessed.

## Database Operations

The application uses the [IBM Cloudant library](https://github.com/IBM/cloudant-node-sdk) to interact with CouchDB, which provides a comprehensive API for document operations, queries, and indexing.

### CRUD operations

The database operations are handled through the `CouchDBConnector` class in `server/database/couchdb.ts`, which provides a general abstraction and error handling logic:

- **Create**: `createDocument()` - Creates a new document
- **Read**: `getDocument()` - Retrieves a document by ID
- **Update**: `updateDocument()` - Updates an existing document (requires revision)
- **Delete**: `deleteDocument()` - Deletes a document (requires revision)
- **Query**: `queryDocuments()` - Performs Mango queries for complex searches

The `CouchDBConnector` is instantiated as `couchDB` and exported for use throughout the application. For specific document types, service classes provide domain-specific methods that build on the connector's abstract methods. For example, the `UserService` class in `server/crud/users.ts` provides user-specific operations.

### Indexing

CouchDB uses indexes to improve query performance. The indices created by the application are defined in `server/crud/indices.ts`.

- `type_userid_idx`: For querying documents by type and user ID.

## Configuration

The database connection is configured through environment variables:

- `CLOUDANT_URL`: CouchDB server URL (default: http://localhost:5984)
- `CLOUDANT_USERNAME`: Username for authentication
- `CLOUDANT_PASSWORD`: Password for authentication
- `CLOUDANT_DATABASE`: Database name (default: 'firn')

Set these in your application's environment.

### Testing Database Connection

To test your database connection, you can run

```bash
pnpm db:test
```

## Initialize Database

To create the first administrator user, you need to set the environment variable `FIRST_ADMIN_EMAIL` to a valid `@scilifelab.se` e-mail, for example `firn.user@scilifelab.se`. Then you can run the database initialization script:

```bash
pnpm db:init
```

This will create the respective administrator account in the database, unless an administrator already exists. In that case, ask that administrator to create or approve your account via the user interface instead.