---
description: Rules to apply when data needs to be fetched from the server with Pinia Colada
alwaysApply: false
---

# Data fetching with Pinia Colada

**ALWAYS use key factories and `defineQueryOptions()` for ALL queries** - this ensures type safety, organization, and prevents typos. Never use simple static keys or inline query definitions.

## Query Organization Structure

Organize queries by domain in separate files in `app/utils/queries/`:

```bash
tree .app/utils/queries/
├── boards.ts
├── documents.ts
├── users.ts
└── [domain].ts
```

## Hierarchical key pattern (MANDATORY)

Nest keys to create a hierarchy of queries. For example, let's say you have a query that fetches the information of a product with all its details while you have another one that only fetches a summary of that product to be shown in a search. Their keys would look like this:

```ts
// gets the product with all its details
useQuery({
  key: () => ['products', productId.value],
  query: () => getProductById(productId.value),
})
// gets a product summary suited for searches
useQuery({
  key: () => ['products', productId.value, { searchResult: true }],
  query: () => getProductSummaryById(productId.value),
})

Always use hierarchical keys. Sharing the same root key allows to invalidate all the data related to a specific product at once with 

```ts
queryCache.invalidateQueries({ key: ['products', productId.value] })
// or even
queryCache.invalidateQueries({
  key: [
    'products',
    productId.value,
    {}, // partially match { searchResult: true }
  ],
})
```

These _key filters_ are used in many places, [query invalidation](./query-invalidation.md) is just one of them.

When creating query keys, organize your keys precisely to take advantage of this feature.

Keys can contain strings, numbers, objects, and arrays. Anything that is serializable to JSON can be used in a key. Keep in mind these rules when writing keys:

- `['doc', 2]` and `['doc', '2']` are different keys
- Within objects, `undefined` is stripped out but `null` is not. Therefore `['doc', { withComments: undefined }]` is equivalent to `['doc', {}]` and matches both `withComments: true` and `withComments: false`
- Arrays are also partially matched so `['doc', ['nested', 'array']]` is matched by `['doc', ['nested']]` but not by `['doc', ['nested', 'array', 'other']]`.

## Key Factory Pattern (MANDATORY)

Every query file MUST export a key factory object:

```typescript
export const [DOMAIN]_QUERY_KEYS = {
  root: ['[domain]'] as const,
  byId: (id: string) => [...[DOMAIN]_QUERY_KEYS.root, id] as const,
  list: (filters?: object) => [...[DOMAIN]_QUERY_KEYS.root, 'list', filters] as const,
  // Add more specific keys as needed
} as const
```

## Query Options Definition (MANDATORY)

Use `defineQueryOptions()` for ALL queries:

```typescript
// For static queries
export const [domain]ListQuery = defineQueryOptions({
  key: [DOMAIN]_QUERY_KEYS.list(),
  query: () => get[Domain]List(),
})

// For dynamic queries
export const [domain]ByIdQuery = defineQueryOptions(
  (id: string) => ({
    key: [DOMAIN]_QUERY_KEYS.byId(id),
    query: () => get[Domain]ById(id),
  })
)

// For complex dynamic queries
export const [domain]ByIdWithOptionsQuery = defineQueryOptions(
  ({ id, withComments = false }: { id: string; withComments?: boolean }) => ({
    key: [DOMAIN]_QUERY_KEYS.byIdWithComments(id, withComments),
    query: () => get[Domain]ById(id, { withComments }),
  })
)
```