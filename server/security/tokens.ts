import 'dotenv/config'
import type { H3Event } from 'h3'
import type { KeyObject } from 'crypto'
import type { FirnUser } from '../../types/auth'
import type { FirnJWTPayload, FirnUserToken } from '../../types/tokens'
import { UserService } from '../crud/users'
import { couchDB } from '../database/couchdb'
import { DateTime } from 'luxon'

// generates a key that can be used for signing and verifying JWTs and encrypting and decrypting JWEs
import { createSecretKey, randomBytes, scryptSync } from 'crypto'

// uses the JSON Web Signature (JWS) specification to create a signature for the JWT using the previously generated symmetric key.
// provides a function to verify the signature of a JWT using the previously generated symmetric key.
import { jwtDecrypt, EncryptJWT } from 'jose'

/*
 * Token Handler - Table of Contents
 * *********************************
 *
 *
 * INCOMING REQUEST HANDLING:
 * extractTokenFromHeader(event) - Extract a token from a H3 server event if it exists - typically from an API request (REST / tRPC)
 *
 * CRYPTOGRAPHY:
 * generateCustomKey() - Generate a symmetric key for a user-specific encryption and decryption (if the actual token will be stored in the database instead of being ephemeral)
 *
 * VERIFY TOKENS:
 * verifyFirnUserToken(token, expectedAudience?, keySource?) - Verify a user token with the given expected audience and an optional key source
 * verifyToken(token, customKey?) - Verify the signature of a token
 *
 * ISSUE TOKENS:
 * generateToken(userId, expiresAt) - Generate a token for the given user ID and expiration time
 * generateTokenWithClaims(userId, audience, expiresAt) - Generate a token for the given user ID and audience and expiration time
 */

export class TokenHandler {
  private issuer: string
  private secretKey: KeyObject

  constructor() {
    // derive a symmetric key from the session password
    if (!process.env.NUXT_SESSION_PASSWORD) {
      throw new Error('NUXT_SESSION_PASSWORD is not set in environment variables, cannot generate tokens')
    }
    if (!process.env.NUXT_SESSION_SALT) {
      throw new Error('NUXT_SESSION_SALT is not set in environment variables, cannot generate tokens')
    }
    this.secretKey = createSecretKey(scryptSync(process.env.NUXT_SESSION_PASSWORD, process.env.NUXT_SESSION_SALT, 32))
    this.issuer = `urn:${(process.env.NUXT_APP_URL ?? 'NGI-FIRN').toLowerCase().replace(/[^a-z0-9]/g, '')}`
    console.log('Tokens will be issued by:', this.issuer)
  }

  /*
     * Extract a token from a H3 server event if it exists - typically from an API request (REST / tRPC)
     */
  public async extractTokenFromHeader(event: H3Event): Promise<string | undefined> {
    const authHeader = getRequestHeader(event, 'authorization')
    if (authHeader) {
      const [method, token] = authHeader.split(' ')
      if (method.toLowerCase() === 'bearer' && token) {
        return token
      }
    }
  }

  public async generateCustomKey(keySource: string): Promise<KeyObject> {
    if (!process.env.NUXT_SESSION_SALT) {
      throw new Error('NUXT_SESSION_SALT is not set in environment variables, cannot generate keys')
    }
    return createSecretKey(scryptSync(keySource, process.env.NUXT_SESSION_SALT, 32))
  }

  public async verifyFirnUserToken(token: string, expectedAudience?: string): Promise<{ user: FirnUser | null, token: FirnUserToken | null, error?: string }> {
    
    /*
    * If the token is a barcode token, it consists of four parts:
    * - the prefix "fbt" followed by the user's Firn ID and a random string.
    * - the user's Firn ID is the ID of the user in the Firn database.
    * - the token ID
    * - a random string that was together with the token ID used to generate the custom key.
    */

    let customKey: KeyObject | undefined
    if (token.startsWith('fbt')) {
      const barcode = token.split('fbt')[1]
      // the FirnID is generated by Math.random().toString(36).substring(3, 10)
      // so it is always 7 characters long
      const firnId = barcode.substring(0, 7)
      const tokenID = barcode.substring(7, 14)
      const randomString = barcode.substring(14)
      customKey = await this.generateCustomKey(tokenID + randomString)
      const barcodeUser = await UserService.matchFirnUserByFirnQuery({ firnId: firnId })
      if (!barcodeUser) {
        return { user: null, token: null, error: 'Invalid barcode token' }
      }
      const barcodeUserTokens = barcodeUser.tokens as FirnUserToken[]
      const existingToken = barcodeUserTokens.find(token => token.tokenID === tokenID)?.encryptedToken?.toString() ?? ''
      // If there is no encrypted token found or the custom key was not generated, return an error
      if (!existingToken && !customKey) {
        return { user: null, token: null, error: 'Invalid barcode token' }
      } else {
        token = existingToken
      }
    }
    
    // If the token is not a barcode token, verify the token as usual
    
    const audienceClaim = expectedAudience ? expectedAudience.toLowerCase().replace(/[^a-z0-9]/g, '') : ''
    const result = await this.verifyToken(token, customKey)
    const success = result.success
    const payload = result.payload
    const error = result.error

    if (error) {
      return { user: null, token: null, error: error }
    }

    if (audienceClaim && payload?.aud !== `urn:${audienceClaim}`) {
      return { user: null, token: null, error: 'Token audience does not match expected audience' }
    }

    if (success && payload) {
      const user = await couchDB.getDocument<FirnUser>(payload.udoc)
      if (user) {
        const userTokens = user.tokens as FirnUserToken[]
        const existingToken = userTokens.find(token => token.tokenID === payload.tid)
        if (existingToken) {
          return { user: user, token: existingToken }
        }
        else {
          return { user: null, token: null, error: 'Token ID not found in user tokens' }
        }
      }
      else {
        return { user: null, token: null, error: 'User not found' }
      }
    }
    else {
      return { user: null, token: null, error: 'Token verification failed' }
    }
  }

  private async verifyToken(token: string, customKey?: KeyObject): Promise<{ success: boolean, payload?: FirnJWTPayload, error?: string }> {
    try {
      const { payload } = await jwtDecrypt(token, customKey ?? this.secretKey, {
        issuer: this.issuer
      })
      return { success: true, payload: payload as FirnJWTPayload }
    }
    catch (error) {
      return { success: false, error: (error as Error).message }
    }
  }

  // generate a JWT for the given audience and expiration time
  private async generateTokenWithPublicClaims(payload: FirnJWTPayload, audience?: string, expiresAt?: string, customKey?: KeyObject): Promise<string> {
    let token: string
    const audienceClaim = audience ? audience.toLowerCase().replace(/[^a-z0-9]/g, '') : ''

    // optionally a token without any specific audience to allow requesting any resource can be created
    if (audience == '') {
      token = await new EncryptJWT(payload)
        .setProtectedHeader({ alg: 'dir', enc: 'A256GCM' })
        .setIssuedAt()
        .setIssuer(this.issuer)
        .setExpirationTime(expiresAt ? DateTime.fromISO(expiresAt).toUnixInteger() : DateTime.now().plus({ days: 7 }).toUnixInteger())
        .encrypt(customKey ?? this.secretKey)
    }
    else {
      token = await new EncryptJWT(payload)
        .setProtectedHeader({ alg: 'dir', enc: 'A256GCM' })
        .setIssuedAt()
        .setIssuer(this.issuer)
        .setAudience(`urn:${audienceClaim}`)
        .setExpirationTime(expiresAt ? DateTime.fromISO(expiresAt).toUnixInteger() : DateTime.now().plus({ days: 7 }).toUnixInteger())
        .encrypt(customKey ?? this.secretKey)
    }
    return token
  }

  public async generateFirnUserToken(user: FirnUser, tokenType: 'barcode' | 'qrcode', audience?: string, expiresAt?: string): Promise<{ jwt: string, tokenID: string, user: FirnUser } | null> {
    // retrieve existing user tokens
    const userTokens = user.tokens as FirnUserToken[]

    // get a unique token ID for that user
    // while loop continues until a unique token ID is found by randomly generating a string and checking if it is already in the user tokens
    let newTokenID: string
    do {
      newTokenID = Math.random().toString(36).substring(3, 10)
    } while (userTokens.some(token => token.tokenID === newTokenID))

    // generate new token payload
    const payload: FirnJWTPayload = {
      tid: newTokenID,
      udoc: user._id
    }

    // default to one week
    if (!expiresAt) {
      expiresAt = DateTime.now().plus({ days: 7 }).toISO()
    }

    // no specific audience given
    if (!audience) {
      audience = ''
    }

    const newToken: FirnUserToken = {
      type: 'firn-token',
      schema: 1,
      tokenID: payload.tid,
      audience: audience,
      expiresAt: expiresAt,
      lastUsedAt: DateTime.now().toISO(),
      createdAt: DateTime.now().toISO(),
      encryptedToken: null
    }

    // update the user tokens with the new token
    const updatedUserTokens = userTokens.concat([newToken])
    const updatedUser: Partial<FirnUser> = {
      tokens: updatedUserTokens
    }

    /*
    * There is no barcode standard that could accommodate the JWT, so we need to store it instead in the database.
    * If the JWT itself is ephemeral, we encrypt it symmetrically with the standard key derived 
    * from the Nuxt session password (this.secretKey). If the JWT needs to be stored, we generate a custom key
    * for each token. Instead of the actual JWT, we encode the ephemeral string that is used to generate the key
    * in the barcode instead. Only the possession of the barcode therefore allows to decrypt the JWT and potentially
    * verify it.
    */

    let jwt: string
    
    if (tokenType === 'barcode') {
    // Use a cryptographically secure random string generator via randomBytes.
      const randomString = randomBytes(5).toString('hex')
      const customKey = await this.generateCustomKey(newTokenID + randomString)
      jwt = await this.generateTokenWithPublicClaims(payload, audience, expiresAt, customKey)
      const barcodeString = 'fbt' + user.firnId + newTokenID + randomString // "fbt" for "Firn Barcode Token"
      // Store the actual JWT in the database, return the barcode string instead
      newToken.encryptedToken = jwt
      jwt = barcodeString
    } else {
      // For QR codes, we can use the JWT directly
      jwt = await this.generateTokenWithPublicClaims(payload, audience, expiresAt, undefined)
    }

    if (user && jwt) {
      // Update the user
      const result = await couchDB.updateDocument(user._id, { ...user, ...updatedUser }, user._rev!)
      if (result) {
        return { jwt, tokenID: newTokenID, user: { ...user, ...updatedUser, _id: result.id, _rev: result.rev } as FirnUser }
      }
    }
    return null
  }

  public async deleteFirnUserToken(user: FirnUser, tokenID: string[]): Promise<FirnUser | null> {
    // retrieve existing user tokens
    const userTokens = user.tokens as FirnUserToken[]

    // Filter out tokens that match the provided IDs
    const updatedTokens = userTokens.filter(token => !tokenID.includes(token.tokenID))

    const updatedUser: Partial<FirnUser> = {
      tokens: updatedTokens
    }

    const result = await couchDB.updateDocument(user._id, { ...user, ...updatedUser }, user._rev!)
    if (result) {
      return { ...user, ...updatedUser, _id: result.id, _rev: result.rev } as FirnUser
    }

    return null
  }
}

// Export a singleton instance with default configuration
export const tokenHandler = new TokenHandler()
